# -*- mode: snippet -*-
# name: cbicoef
# key: cbicoef
# For bicoef library for competitive programming
# --
pub mod bicoef {
    use std::mem;
    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};
    type MIType = i64;
    const MOD: MIType = 1_000_000_007;

    pub struct ModInt(MIType);
    impl Clone for ModInt {
        fn clone(&self) -> Self {
            Self(self.0)
        }
    }
    impl Copy for ModInt {}

    impl ModInt {
        pub fn new<T>(x: T) -> Self
        where
            MIType: From<T>,
        {
            let mut x = MIType::from(x);
            if x >= MOD {
                x -= MOD;
            }
            ModInt(x)
        }

        fn inverse(&self) -> Self {
            let mut a = self.0;
            let mut b = MOD;
            let mut u = 1;
            let mut v = 0;
            let mut t;
            while b > 0 {
                t = a / b;
                a -= t * b;
                mem::swap(&mut a, &mut b);
                u -= t * v;
                mem::swap(&mut u, &mut v);
            }
            Self(u)
        }

        pub fn pow(&self, e: i32) -> Self {
            let mut a = 1;
            let mut p = self.0;
            let mut e = e;
            while e > 0 {
                match e & 2 {
                    0 => {
                        p = (p * p) % MOD;
                        e /= 2;
                    }
                    _ => {
                        a = (a * p) % MOD;
                        e -= 1;
                    }
                }
            }
            Self(a)
        }

        pub fn get(&self) -> MIType {
            self.0
        }
    }

    impl From<ModInt> for MIType {
        fn from(m: ModInt) -> Self {
            m.get()
        }
    }

    impl<T> AddAssign<T> for ModInt
    where
        MIType: From<T>,
    {
        fn add_assign(&mut self, rhs: T) {
            let rhs = MIType::from(rhs);
            self.0 += rhs;
            if self.0 >= MOD {
                self.0 -= MOD;
            }
        }
    }

    impl<T> Add<T> for ModInt
    where
        MIType: From<T>,
    {
        type Output = ModInt;
        fn add(self, rhs: T) -> Self::Output {
            let mut res = self;
            res += rhs;
            res
        }
    }

    impl<T> SubAssign<T> for ModInt
    where
        MIType: From<T>,
    {
        fn sub_assign(&mut self, rhs: T) {
            let rhs = MIType::from(rhs);
            if rhs > 0 {
                self.0 += MOD - rhs;
            }

            if self.0 >= MOD {
                self.0 -= MOD;
            }
        }
    }

    impl<T> Sub<T> for ModInt
    where
        MIType: From<T>,
    {
        type Output = ModInt;
        fn sub(self, rhs: T) -> Self::Output {
            let mut res = self;
            res -= rhs;
            res
        }
    }

    impl<T> MulAssign<T> for ModInt
    where
        MIType: From<T>,
    {
        fn mul_assign(&mut self, rhs: T) {
            let rhs = MIType::from(rhs);
            self.0 = self.0 * rhs % MOD;
        }
    }

    impl<T> Mul<T> for ModInt
    where
        MIType: From<T>,
    {
        type Output = ModInt;
        fn mul(self, rhs: T) -> Self::Output {
            let mut res = self;
            res *= rhs;
            res
        }
    }

    impl<T> DivAssign<T> for ModInt
    where
        MIType: From<T>,
    {
        fn div_assign(&mut self, rhs: T) {
            let rhs = MIType::from(rhs);
            let inv = Self(rhs).inverse();
            self.0 *= inv.get();
            self.0 %= MOD;
        }
    }

    impl<T> Div<T> for ModInt
    where
        MIType: From<T>,
    {
        type Output = ModInt;
        fn div(self, rhs: T) -> Self::Output {
            let mut res = self;
            res *= rhs;
            res
        }
    }    
    pub struct BiCoef {
        fact: Vec<ModInt>,
        ifact: Vec<ModInt>,
    }

    impl BiCoef {
        pub fn new(n: usize) -> Self {
            let mut fact = vec![ModInt::new(1); n + 1];
            let mut ifact = vec![ModInt::new(1); n + 1];

            for i in 1..=n {
                fact[i] = fact[i - 1] * i;
            }
            ifact[n] = fact[n].inverse();
            for i in range(3, n + 1).rev() {
                ifact[i - 1] = ifact[i] * i;
            }
            BiCoef {
                fact: fact,
                ifact: ifact,
            }
        }

        pub fn comb(&self, n: usize, r: usize) {
            self.fact[n] * (self.ifact[r] * self.ifact[n - r])
        }
    }
}