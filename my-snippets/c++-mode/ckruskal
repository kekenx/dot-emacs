# -*- mode: snippet -*-
# name: ckruskal
# key: ckruskal
# For kruskal library for competitive programming
# --

class DSU {
private:
  std::vector<int> rank, p, size;
public:
  DSU(int n): rank(n, 0), p(n), size(n, 1) {
    for (int i = 0; i < n; ++i) p[i] = i;
  }

  int findRep(int x) {
    if (p[x] != x) {
      p[x] = findRep(p[x]);
    }
    return p[x];
  }

  void unite(int x, int y) {
    int p1 = findRep(x), p2 = findRep(y);
    if (p1 == p2) return;
    if (rank[p1] < rank[p2]) std::swap(p1, p2);

    if (rank[p1] == rank[p2]) rank[p1]++;
    p[p2] = p1;
    size[p1] += size[p2];
  }

  int getSize(int x) {
    int xRep = findRep(x);
    return p[xRep];
  }

  bool isSame(int x, int y) {
    return findRep(x) == findRep(y);
  }
};

template <typename T>
struct Edge {
  int from, to;
  T cost;
  Edge(int f, int t, T c): from(f), to(t), cost(c){};
  bool operator < (const Edge &e) const {
    return cost < e.cost;
  }
};

template <typename T>
T kruskal(vector< Edge<T> > &G, int n) {
  T total = 0;
  sort(G.begin(), G.end());
  DSU d = DSU(n);
  for (size_t i = 0; i < G.size(); ++i) {
    Edge<T> e = G[i];
    if (d.findRep(e.to) != d.findRep(e.from)) {
      d.unite(e.to, e.from);
      total += e.cost;
    }
  }
  return total;
}