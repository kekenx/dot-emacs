# -*- mode: snippet -*-
# name: cmodint
# key: cmodint
# For modint library for competitive programming
# --

template<typename T, T mod>
struct modint {
private:
  T x;

public:
  modint(): x((T)0) {}
  modint(T y): x(y >= 0? y % mod: (mod - (-y) % mod) % mod) {}

  T get() {
    return x;
  }

  modint &operator+=(const modint &p) {
    if ((x += p.x) >= mod) x -= mod;
    return *this;
  }

  modint &operator-=(const modint &p) {
    if ((x += mod - p.x) >= mod) x -= mod;
    return *this;
  }

  modint &operator*=(const modint &p) {
    x = x * p.x % mod;
    return *this;
  }

  modint &operator/=(const modint &p) {
    *this *= p.inverse();
    return *this;
  }

  modint operator-() const { return modint(-x); }
  modint operator+(const modint &p) const {return modint(*this) += p; }
  modint operator-(const modint &p) const {return modint(*this) -= p; }
  modint operator*(const modint &p) const {return modint(*this) *= p; }
  modint operator/(const modint &p) const {return modint(*this) /= p; }

  bool operator==(const modint &p) const { return x == p.x; }
  bool operator!=(const modint &p) const { return x != p.x; }

  modint inverse() const {
    T a = x, b = mod, u = 1, v = 0, t;
    while (b > 0) {
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    return modint(u);
  }

  modint pow(int e) const {
    T a = 1, p = x;
    while(e > 0) {
      if (e % 2 == 0) {
	p = (p * p) % mod;
	e /= 2;
      } else {
	a = (a * p) % mod;
	e--;
      }
    }
    return modint(a);
  }
};

const long long MOD = 1000000007;

using mi = modint<long long, MOD>;